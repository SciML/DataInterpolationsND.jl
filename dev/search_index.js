var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Structs","page":"API","title":"Structs","text":"","category":"section"},{"location":"api/#Multi-point-evaluation","page":"API","title":"Multi-point evaluation","text":"","category":"section"},{"location":"api/#DataInterpolationsND.NDInterpolation","page":"API","title":"DataInterpolationsND.NDInterpolation","text":"NDInterpolation(u, interp_dims; cache = EmptyCache())\n\nThe interpolation object containing the interpolation dimensions and the data to interpolate u. Given the number of interpolation dimensions N_in, for first N_in dimensions of u the size of u along that dimension must match the length of t of the corresponding interpolation dimension.\n\nArguments\n\ninterp_dims: A tuple of identically typed interpolation dimensions.\nu: The array to be interpolated.\n\nKeyword Arguments\n\ncache: Optional global cache\n\n\n\n\n\n","category":"type"},{"location":"api/#DataInterpolationsND.LinearInterpolationDimension","page":"API","title":"DataInterpolationsND.LinearInterpolationDimension","text":"LinearInterpolationDimension(t; t_eval = similar(t, 0))\n\nInterpolation dimension for linear interpolation between the data points.\n\nArguments\n\nt: The time points for this interpolation dimension.\n\nKeyword arguments\n\nt_eval: A vector (like) of time evaluation points for efficient evaluation of multiple points, see eval_unstructured and eval_grid. Defaults to no points.\n\n\n\n\n\n","category":"type"},{"location":"api/#DataInterpolationsND.ConstantInterpolationDimension","page":"API","title":"DataInterpolationsND.ConstantInterpolationDimension","text":"ConstantInterpolationDimension(t; t_eval = similar(t, 0), left = true)\n\nInterpolation dimension for constant interpolation between the data points.\n\nArguments\n\nt: The time points for this interpolation dimension.\n\nKeyword arguments\n\nleft: Whether the interpolation looks to the left of the evaluation t for the value. Defaults to true.\nt_eval: A vector (like) of time evaluation points for efficient evaluation of multiple points, see eval_unstructured and eval_grid. Defaults to no points.\n\n\n\n\n\n","category":"type"},{"location":"api/#DataInterpolationsND.BSplineInterpolationDimension","page":"API","title":"DataInterpolationsND.BSplineInterpolationDimension","text":"BSplineInterpolationDimension(\n    t, degree;\n    t_eval = similar(t, 0),\n    max_derivative_order_eval::Integer = 0,\n    multiplicities::Union{AbstractVector{<:Integer}, Nothing} = nothing)\n\nInterpolation dimension for BSpline or NURBS interpolation between the data points, used for evaluating the BSpline basis functions.\n\nArguments\n\nt: The time points for this interpolation dimension, in this context also known as knots.\ndegree: The degree of the basis functions\n\nKeyword arguments\n\nt_eval: A vector (like) of time evaluation points for efficient evaluation of multiple points, see eval_unstructured and eval_grid. Defaults to no points.\nmax_derivative_order_eval: The maximum derivative order for which the basis functions will be precomputed for eval_unstructured and eval_grid.\nmultiplicities: The multiplicities of the knots t. Defaults to multiplicities for an open/clamped knot vector.\n\n\n\n\n\n","category":"type"},{"location":"api/#DataInterpolationsND.NURBSWeights","page":"API","title":"DataInterpolationsND.NURBSWeights","text":"NURBSWeights(weights::AbstractArray)\n\nWeights associated with the control points to define a NURBS geometry.\n\n\n\n\n\n","category":"type"},{"location":"api/#DataInterpolationsND.eval_unstructured","page":"API","title":"DataInterpolationsND.eval_unstructured","text":"function eval_unstructured(\n    interp::NDInterpolation{N_in};\n    derivative_orders::NTuple{N_in, <:Integer} = ntuple(_ -> 0, N_in)) where {N_in}\n\nEvaluate the interpolation in the unstructured set of points defined by t_eval in the interpolation dimensions out of place. That is, t_eval must have the same length for each interpolation dimension and the interpolation is evaluated at the zip if these t_eval.\n\nKeyword arguments\n\nderivative_orders: The partial derivative order for each interpolation dimension. Defaults to 0 for each.\n\n\n\n\n\n","category":"function"},{"location":"api/#DataInterpolationsND.eval_unstructured!","page":"API","title":"DataInterpolationsND.eval_unstructured!","text":"function eval_unstructured!(\n    out::AbstractArray,\n    interp::NDInterpolation{N_in};\n    derivative_orders::NTuple{N_in, <:Integer} = ntuple(_ -> 0, N_in)) where {N_in}\n\nEvaluate the interpolation in the unstructured set of points defined by t_eval in the interpolation dimensions in place. That is, t_eval must have the same length for each interpolation dimension and the interpolation is evaluated at the zip if these t_eval.\n\nKeyword arguments\n\nderivative_orders: The partial derivative order for each interpolation dimension. Defaults to 0 for each.\n\n\n\n\n\n","category":"function"},{"location":"api/#DataInterpolationsND.eval_grid","page":"API","title":"DataInterpolationsND.eval_grid","text":"function eval_grid(\n    interp::NDInterpolation{N_in};\n    derivative_orders::NTuple{N_in, <:Integer} = ntuple(_ -> 0, N_in)) where {N_in}\n\nEvaluate the interpolation in the Cartesian product of the t_eval of the interpolation dimensions out of place.\n\nKeyword arguments\n\nderivative_orders: The partial derivative order for each interpolation dimension. Defaults to 0 for each.\n\n\n\n\n\n","category":"function"},{"location":"api/#DataInterpolationsND.eval_grid!","page":"API","title":"DataInterpolationsND.eval_grid!","text":"function eval_grid!(\n    out::AbstractArray,\n    interp::NDInterpolation{N_in};\n    derivative_orders::NTuple{N_in, <:Integer} = ntuple(_ -> 0, N_in)) where {N_in}\n\nEvaluate the interpolation in the Cartesian product of the t_eval of the interpolation dimensions in place.\n\nKeyword arguments\n\nderivative_orders: The partial derivative order for each interpolation dimension. Defaults to 0 for each.\n\n\n\n\n\n","category":"function"},{"location":"splines/#Splines","page":"Splines","title":"Splines","text":"To be expanded. A nice thing to demonstrate is the plotting of the basis functions:\n\nusing DataInterpolationsND\nusing Plots\n\nitp_dim = BSplineInterpolationDimension(\n    [1.0, 2.0, 3.0, 5.0, 8.0], 3; t_eval = collect(range(1.0, 8.0; length = 100))\n)\nplot(itp_dim)","category":"section"},{"location":"interpolation_types/#Interpolation-types","page":"Interpolation Types","title":"Interpolation types","text":"using DataInterpolationsND\nusing Random\nusing Plots\nRandom.seed!(2)\n\nt1 = cumsum(0.5 .+ rand(10))\nt2 = cumsum(0.5 .+ rand(10))\n\nt1_eval = collect(range(first(t1), last(t1); length = 100))\nt2_eval = collect(range(first(t2), last(t2); length = 100))\n\nu = rand(10, 10)\nout = zeros(100, 100)\nnothing # hide","category":"section"},{"location":"interpolation_types/#Linear-Interpolation","page":"Interpolation Types","title":"Linear Interpolation","text":"interp_dims = (\n    LinearInterpolationDimension(t1; t_eval = t1_eval),\n    LinearInterpolationDimension(t2; t_eval = t2_eval)\n)\ninterp = NDInterpolation(u, interp_dims)\neval_grid!(out, interp)\nheatmap(out)","category":"section"},{"location":"interpolation_types/#Constant-Interpolation","page":"Interpolation Types","title":"Constant Interpolation","text":"interp_dims = (\n    ConstantInterpolationDimension(t1; t_eval = t1_eval),\n    ConstantInterpolationDimension(t2; t_eval = t2_eval)\n)\ninterp = NDInterpolation(u, interp_dims)\neval_grid!(out, interp)\nheatmap(out)","category":"section"},{"location":"interpolation_types/#BSpline-Interpolation","page":"Interpolation Types","title":"BSpline Interpolation","text":"interp_dims = (\n    BSplineInterpolationDimension(t1, 2; t_eval = t1_eval),\n    BSplineInterpolationDimension(t2, 2; t_eval = t2_eval)\n)\nu_bspline = rand(11, 11) # per dimension this is `sum(multiplicities) - degree - 1 = 11`\nu_bspline[1:10, 1:10] = u\ninterp = NDInterpolation(u_bspline, interp_dims)\neval_grid!(out, interp)\nheatmap(out)","category":"section"},{"location":"interpolation_types/#NURBS-Interpolation","page":"Interpolation Types","title":"NURBS Interpolation","text":"weights = rand(11, 11)\ninterp = NDInterpolation(u_bspline, interp_dims; cache = NURBSWeights(weights))\neval_grid!(out, interp)\nheatmap(out)","category":"section"},{"location":"usage/#Single-point-evaluation","page":"Usage","title":"Single point evaluation","text":"","category":"section"},{"location":"usage/#Setup","page":"Usage","title":"Setup","text":"using DataInterpolationsND\nusing Random\nRandom.seed!(1)\n\ninterp_dims = (\n    LinearInterpolationDimension(cumsum(0.5 .+ rand(5))),\n    LinearInterpolationDimension(cumsum(0.5 .+ rand(10)))\n)\n\nt_eval_1 = range(\n    first(interp_dims[1].t),\n    last(interp_dims[1].t),\n    length = 100\n)\nt_eval_2 = range(\n    first(interp_dims[2].t),\n    last(interp_dims[2].t),\n    length = 100\n)","category":"section"},{"location":"usage/#Scalar-output","page":"Usage","title":"Scalar output","text":"using Plots\n\nu = rand(5, 10)\nitp = NDInterpolation(u, interp_dims)\nout = itp.(t_eval_1, t_eval_2')\nheatmap(out)","category":"section"},{"location":"usage/#Vector-output,-out-of-place","page":"Usage","title":"Vector output, out of place","text":"u = reshape(u, 5, 10, 1)\nitp = NDInterpolation(u, interp_dims)\nout = itp.(t_eval_1, t_eval_2')\nheatmap(map(only, out))","category":"section"},{"location":"usage/#vector-output,-in-place","page":"Usage","title":"vector output, in place","text":"out = zeros(100, 100)\nfor I in CartesianIndices(out)\n    i, j = Tuple(I)\n    itp(view(out, i, j:j), t_eval_1[i], t_eval_2[j])\nend\nheatmap(out)","category":"section"},{"location":"usage/#Single-point-derivative-evaluation","page":"Usage","title":"Single point derivative evaluation","text":"","category":"section"},{"location":"usage/#Partial-derivative-w.r.t.-first-input-(ForwardDiff)","page":"Usage","title":"Partial derivative w.r.t. first input (ForwardDiff)","text":"using ForwardDiff\n\nu = reshape(u, 5, 10)\nitp = NDInterpolation(u, interp_dims)\n∂₁itp = (t1, t2) -> ForwardDiff.derivative(t_ -> itp(t_, t2), t1)\nout = ∂₁itp.(t_eval_1, t_eval_2')\nheatmap(out)","category":"section"},{"location":"usage/#Partial-derivative-w.r.t.-first-input-(analytic)","page":"Usage","title":"Partial derivative w.r.t. first input (analytic)","text":"out = itp.(t_eval_1, t_eval_2'; derivative_orders = (1, 0))\nheatmap(out)","category":"section"},{"location":"usage/#Multiple-point-evaluation-(using-KA)","page":"Usage","title":"Multiple point evaluation (using KA)","text":"","category":"section"},{"location":"usage/#Unstructured-multi-point-scalar-evaluation-(out-of-place)","page":"Usage","title":"Unstructured multi-point scalar evaluation (out of place)","text":"using LinearAlgebra\n\ninterp_dims = (\n    LinearInterpolationDimension(interp_dims[1].t; t_eval = t_eval_1),\n    LinearInterpolationDimension(interp_dims[2].t; t_eval = t_eval_2)\n)\nitp = NDInterpolation(u, interp_dims)\n\nout = eval_unstructured(itp)\nheatmap(diagm(out))","category":"section"},{"location":"usage/#Grid-vector-evaluation-(in-place)","page":"Usage","title":"Grid vector evaluation (in place)","text":"u = reshape(u, 5, 10, 1)\nitp = NDInterpolation(u, interp_dims)\nout = zeros(100, 100, 1)\neval_grid!(out, itp)\nheatmap(out[:, :, 1])","category":"section"},{"location":"#Index","page":"Index","title":"Index","text":"DataInteprolationsND.jl is a library for interpolating arbitrarily high dimensional array data. The domain of this interpolation is a (hyper)rectangle. Support is included for efficient evaluation at multiple points in the domain through KernelAbstractions.jl.\n\nFor one dimensional interpolation see also DataInterpolations.jl.","category":"section"},{"location":"#API","page":"Index","title":"API","text":"An NDInterpolation is defined by a tuple of interpolation dimensions and the data u to interpolate.\n\nusing DataInterpolationsND\n\nt1 = cumsum(rand(5))\nt2 = cumsum(rand(7))\n\ninterpolation_dimensions = (\n    LinearInterpolationDimension(t1),\n    LinearInterpolationDimension(t2)\n)\n\n# The outputs will be vectors of length 2\nu = rand(5, 7, 2)\n\ninterp = NDInterpolation(u, interpolation_dimensions)\n\nEvaluation of this vector valued interpolation can be done in place or out of place.\n\ninterp(0.5, 0.5)\n\nout = zeros(2)\ninterp(out, 0.5, 0.5)\n\nIf we provide t_eval for the interpolation dimensions, we can evaluate at these points either 'zipped' (where all t_eval must be of the same length) or as a grid defined by the Cartesian product of the t_eval.\n\ninterpolation_dimensions = (\n    LinearInterpolationDimension(t1; t_eval = range(first(t1), last(t1); length = 100)),\n    LinearInterpolationDimension(t2; t_eval = range(first(t2), last(t2); length = 100))\n)\n\ninterp = NDInterpolation(u, interpolation_dimensions)\n\n# Out of place zipped evaluation\neval_unstructured(interp) # Yields Matrix of size (100, 2)\n\n# In place grid evaluation\nout = zeros(100, 100, 2)\neval_grid!(out, interp)\n\nThis is particularly efficient for evaluating the interpolation for the same t_eval multiple times with different values for u, because the indices (and basis functions if applicable) for the t_eval are cached during the interpolation dimension construction.","category":"section"},{"location":"#Available-interpolations","page":"Index","title":"Available interpolations","text":"The interpolation types are given by the corresponding interpolation dimension type.\n\nLinearInterpolationDimension(t): Linear interpolation in the sense of bilinear, trilinear interpolation etc.\nConstantInterpolationDimension(t): An interpolation with a constant value in each interval between t points. The Boolean option left (default true) can be used to indicate which side of the interval in which the input lies determines the output value.\nBSplineInterpolationDimension(t, degree): Interpolation using BSpline basis functions. The input values t are interpreted as knots, and optionally knot multiplicities can be supplied. Per dimension a degree can be specified. Note that for an NDInterpolation of this type, the size of u for a certain dimension is equal to sum(multiplicities) - degree - 1. This interpolation dimension type can also be used to define NURBS, by passing cache = NURBSWeights(weights) to the NDInterpolation constructor.","category":"section"}]
}
